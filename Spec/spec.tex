\documentclass[a4paper, 11pt]{report}

\setlength{\hoffset}{-1.5cm}
\setlength{\voffset}{-1.5cm}
\setlength{\textwidth}{18cm}
\setlength{\textheight}{24cm}
\setlength{\oddsidemargin}{0pt} % Marge gauche sur pages impaires
\setlength{\evensidemargin}{0pt} % Marge gauche sur pages paires

\usepackage[utf8]{inputenc}
\usepackage[frenchb]{babel}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{amsmath}%\overset{min}{\eq}
\usepackage{hyperref}

%\usepackage{csquotes}

\usepackage{listings}
\usepackage{color}


\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}


  \lstdefinelanguage{spegrammar}{
  morekeywords={const,pre,Observators,Constructors,Operators,Observations,service,types,use,require, Refine},
}
 \lstnewenvironment{Spe}
                  {\lstset{
                      language=spegrammar,
                      breaklines=true,
                      showstringspaces=false,
                      keywordstyle=\color{blue},
                      identifierstyle=\small,
                      basicstyle=\small,
                      escapeinside={(*}{*)},
                      tabsize=3,
                      %xleftmargin=0.01\textwidth
                    }
                  }
                  {} 
\newcommand{\specB}[1]{\textbf{#1}}


\begin{document}

\chapter{Projet CPS : Spécifications de River City Ransom}

Béatrice CARRE et Steven VAROUMAS

%% \section*{Introduction}
%% Lien vers l'énoncé du projet : 
%% \href{http://www-master.ufr-info-p6.jussieu.fr/2013/spip.php?action=acceder_document&arg=2148&cle=11624d21d0734169986d403a88c3f6e4e1755b65&file=pdf\%2Fsujet_projet_2014.pdf}{lien}.

\section{Le service Personnage}

\begin{Spe}
service: Personnage
use : Objet
types : String, int, boolean

Observators : 
	const nom : [Personnage] (*$\rightarrow$*) String
	const largeur : [Personnage] (*$\rightarrow$*) int
	const hauteur : [Personnage] (*$\rightarrow$*) int
	const profondeur : [Personnage] (*$\rightarrow$*) int
	const force : [Personnage] (*$\rightarrow$*) int 
	points_de_vie : [Personnage] (*$\rightarrow$*) int
	somme_d_argent : [Personnage] (*$\rightarrow$*) int 
	est_vaincu : [Personnage] (*$\rightarrow$*) boolean 
	est_equipe_objet : [Personnage] (*$\rightarrow$*) boolean
	est_equipe_perso : [Personnage] (*$\rightarrow$*) boolean 
	objet_equipe : [Personnage] (*$\rightarrow$*) Objet
		pre objet_equipe(P) require est_equipe_objet(P)
	perso_equipe : [Personnage] (*$\rightarrow$*) Personnage
		pre perso_equipe(P) require est_equipe_perso(P) 

Constructors : 

	init : String (*$\times$*) int (*$\times$*) int (*$\times$*) int (*$\times$*) int (*$\times$*) int (*$\times$*) int (*$\rightarrow$*) [Personnage]
		pre init(nom,largeur,hauteur,profondeur,force, pdv, argent) require nom = "Alex" (*$\lor$*) nom = "Ryan" (*$\land$*) largeur(*$>$*)0 (*$\land$*) hauteur(*$>$*)0 (*$\land$*) profondeur(*$>$*)0 (*$\land$*) force(*$>$*)0 (*$\land$*) pdv(*$>$*)0 (*$\land$*) argent(*$\ge$*)0 

Operators :
	retrait_vie :  [Personnage] (*$\times$*) int (*$\rightarrow$*) [Personnage]
		pre retrait_vie(P,s) require (*$\lnot$*)est_vaincu(P) (*$\land$*) s(*$>$*)0
	depot_vie : [Personnage] (*$\times$*) int (*$\rightarrow$*) [Personnage]
		pre depot_vie(P,s) require (*$\lnot$*) est_vaincu(P) (*$\land$*) s(*$>$*)0
	retrait_argent :  [Personnage] (*$\times$*) int (*$\rightarrow$*) [Personnage]
		pre retrait_argent(P,s) require (*$\lnot$*)est_vaincu(P) (*$\land$*) s(*$>$*)0 (*$\land$*) somme_d_argent(P) (*$\ge$*) s // pour ne pas avoir une somme negative
	depot_argent : [Personnage] (*$\times$*) int (*$\rightarrow$*) [Personnage]
		pre depot_argent(P,s) require (*$\lnot$*)est_vaincu(P) (*$\land$*) s(*$>$*)0
	ramasser_objet : [Personnage] (*$\times$*) Object (*$\rightarrow$*) [Personnage]
		pre ramasser_objet(P,o) require (*$\lnot$*)est_vaincu(P) (*$\land$*) (*$\lnot$*)est_equipe_objet(P) (*$\land$*)  (*$\lnot$*)est_equipe_perso(P)
        ramasser_perso : [Personnage] (*$\times$*) Personnage (*$\rightarrow$*) [Personnage]
		pre ramasser_perso(P,p) require (*$\lnot$*)est_vaincu(P) (*$\land$*) (*$\lnot$*)est_equipe_objet(P) (*$\land$*) (*$\lnot$*)est_equipe_perso(P)
	jeter : [Personnage] (*$\rightarrow$*) [Personnage]
		pre jeter(P) require (*$\lnot$*)est_vaincu(P) (*$\land$*) ( est_equipe_objet(P) (*$\lor$*) est_equipe_perso (P) )

Observations : 

	[(*$\specB{invariants}$*)]
		est_vaincu(P) (*$\stackrel{min}{=}$*) points_de_vie(P) (*$\le$*) 0
		est_equipe_perso(P) (*$\stackrel{min}{=}$*) perso_equipe(P) (*$\ne$*) null
		est_equipe_objet(P) (*$\stackrel{min}{=}$*) objet_equipe(P) (*$\ne$*) null
		
	[(*$\specB{init}$*)]
		nom(init(n,l,h,p,f,v,a))=n
		largeur(init(n,l,h,p,f,v,a))=l
		hauteur(init(n,l,h,p,f,v,a))=h
		profondeur(init(n,l,h,p,f,v,a))=p
		force(init(n,l,h,p,f,v,a))=f
		points_de_vie(init(n,l,h,p,f,v,a))=v
		somme_d_argent(init(n,l,h,p,f,v,a))=a
		objet_equipe(init(n,l,h,p,f,v,a))=null
		perso_equipe(init(n,l,h,p,f,v,a))=null
                
	[(*$\specB{retrait\_vie}$*)]
		points_de_vie(retrait_vie(P,s)) = points_de_vie(P) - s
		
	[(*$\specB{depot\_vie}$*)]
		points_de_vie(depot_vie(P,s)) = points_de_vie(P) + s 
		
	[(*$\specB{retrait\_argent}$*)]
		somme_d_argent(retrait_argent(P,s)) = argent(P) - s 
		
	[(*$\specB{depot\_argent}$*)]
		somme_d_argent(depot_argent(P,s)) = argent(P) + s 
		
	[(*$\specB{ramasser\_objet}$*)]
		objet_equipe(ramasser_objet(P,objet)) = objet
		force(ramasser_objet(P,objet)) = 
			(*$ \left\{
\begin{array}{ll}
$ force(P) + Objet::bonus\_force(objet) si Objet::est\_equipable(objet) $ \\
$			force(P) sinon $
	 	\end{array} 
\right.$ *)
			
		somme_d_argent(ramasser_objet(P,objet)) = 
			(*$ \left\{
		\begin{array}{ll}
$ somme\_d\_argent(P) + Objet::valeur\_marchande(objet) si Objet::est\_de\_valeur(objet) $ \\
$ somme\_d\_argent(P) sinon $

	 	\end{array} 
\right.$ *)
					
	[(*$\specB{ramasser\_perso}$*)]
		perso_equipe(ramasser_perso(P,perso)) = perso 
		
	[(*$\specB{jeter}$*)]
		perso_equipe(jeter(P)) = null
		force(jeter(P)) = 
		 	(*$ \left\{
\begin{array}{ll}
$force(P) - Objet::bonus\_force(objet\_equipe(P)) $\\$			   si est\_equipe\_objet(P) $\land$ Objet::est\_equipable(objet\_equipe(P)) $ \\
$force(P) sinon $ 
	 	\end{array} 
\right.$ *)			
		objet_equipe(jeter(P)) = null
\end{Spe}
\section{Gangster}
\begin{Spe}
service: Gangster
Refine : Personnage
use : enum ACTION{RIEN,FRAPPE,SAUTE,HAUT,BAS,GAUCHE,DROITE}
Observators :
	action : [Gangster]  (*$\rightarrow$*) ACTION
		pre action(G) require (*$\lnot$*)estVaincu(G)
		

Constructors : 

	init : String (*$\times$*) int (*$\times$*) int (*$\times$*) int (*$\times$*) int (*$\times$*) int (*$\times$*) int (*$\rightarrow$*) [Gangster]
		pre init(nom,largeur,hauteur,profondeur,force, pdv, argent) require nom (*$\neq$*) "" (*$\land$*) largeur(*$>$*)0 (*$\land$*) hauteur(*$>$*)0 (*$\land$*) profondeur(*$>$*)0 (*$\land$*) force(*$>$*)0 (*$\land$*) pdv(*$>$*)0 (*$\land$*) argent(*$\ge$*)0 
		
Observations :
	[(*$\specB{init}$*)]
		nom(init(n,l,h,p,f,v,a))=n
		largeur(init(n,l,h,p,f,v,a))=l
		hauteur(init(n,l,h,p,f,v,a))=h
		profondeur(init(n,l,h,p,f,v,a))=p
		force(init(n,l,h,p,f,v,a))=f
		points_de_vie(init(n,l,h,p,f,v,a))=v
		somme_d_argent(init(n,l,h,p,f,v,a))=a
		objet_equipe(init(n,l,h,p,f,v,a))=null
		perso_equipe(init(n,l,h,p,f,v,a))=null
		action(init(n,l,h,p,f,v,a)) = RIEN
 
\end{Spe}

\section{Bloc}
\begin{Spe}
service : Bloc
use : Objet
types : enum TYPE{VIDE, FOSSE, OBJET},
Observators :
      const type : [Bloc] (*$\rightarrow$*) TYPE
      const objet : [Bloc] (*$\rightarrow$*) Objet
Constructors :
      init : TYPE (*$\times$*) Objet (*$\rightarrow$*) [Bloc]
            pre init(t,o) require 
            (t=VIDE (*$\lor$*) t=FOSSE ) (*$\land$*) o=null) (*$\lor$*) (t=OBJ(*$\land$*) (*$\land$*) o(*$\ne$*)null ) 
Operators :
      retirerObjet : [Bloc] (*$\rightarrow$*) [Bloc]
            pre retirerObjet(B) require type(B)=OBJ(*$\land$*) 
      poserObjet : [Bloc] (*$\times$*) Objet (*$\rightarrow$*) [Bloc]
            pre poserObjet(B,o) require type(B)=VIDE 
Observations :
     
      [(*$\specB{init}$*)]
            type(init(t,o)) = t
            objet(init(t,o)) = o
      [(*$\specB{retirerObjet}$*)]
            type(retirerObjet(B)) = VIDE
            objet(retirerObjet(B)) = null
      [(*$\specB{poserObjet}$*)] 
            type(poserObjet(B,o)) = OBJET
            objet(poserObjet(B,o)) = o 
     
\end{Spe}
 
\section{Objet}
\begin{Spe}


service : Objet 
types : String, boolean, int
Observators :
	const nom : [Object] (*$\rightarrow$*) String
	est_equipable : [Objet] (*$\rightarrow$*) boolean 
	est_de_valeur : [Objet] (*$\rightarrow$*) boolean
	bonus_force : [Objet] (*$\rightarrow$*) int
		pre bonus_force(O) require est_equipable(O) 
	valeur_marchande : [Objet] (*$\rightarrow$*) int
		pre valeur_marchande(O) require est_de_valeur(O)

Constructors :

	init : String (*$\times$*) int (*$\times$*) int (*$\rightarrow$*) [Object] 
		pre(init(n,t,bonus,valeur) require n(*$\ne$*)"" (*$\land$*) ( ( bonus (*$>$*)0 (*$\land$*) valeur = 0) (*$\lor$*) (bonus = 0 (*$\land$*) valeur(*$>$*) 0) ) 
                
Observations : 
	 [(*$\specB{Invariants}$*)]
	        est_equipable(O) (*$\stackrel{min}{=}$*) bonus_force (*$>$*) 0
	        est_de_valeur(O) (*$\stackrel{min}{=}$*) valeur_marchande (*$>$*) 0
	        est_equipable(O) (*$\stackrel{min}{=}$*) (*$\lnot$*)est_de_valeur(O)
	        
	 [(*$\specB{init}$*)]
		nom(init(n,bonus,valeur)) = n 
		bonus_force(init(n,bonus,valeur)) = bonus 
		valeur_marchande(init(n,bonus,valeur)) = valeur 

\end{Spe}

\section{Terrain}
\begin{Spe}
service : Terrain
use : Bloc
types : int
Observators :
	const largeur : [Terrain] (*$\rightarrow$*) int
	const hauteur : [Terrain] (*$\rightarrow$*) int
	const profondeur : [Terrain] (*$\rightarrow$*) int
	bloc : [Terrain] (*$\times$*) int(*$\times$*) int (*$\times$*) int (*$\rightarrow$*) Bloc
		pre bloc( T, i, j, k) require 0 (*$\leq$*) i (*$\leq$*) largeur (*$\land$*) 0 (*$\leq$*) j (*$\leq$*) hauteur(*$\land$*) 0 (*$\leq$*) k (*$\leq$*) profondeur
             
Constructors :

	init : int (*$\times$*) int(*$\times$*) int (*$\rightarrow$*) [Terrain]
		pre init(largeur, hauteur, prof) require largeur (*$>$*) 0 (*$\land$*) hauteur (*$>$*) 0 (*$\land$*) prof (*$>$*) 0
             
Operators : 

	modifier_bloc : [Terrain] (*$\times$*) int (*$\times$*) int (*$\times$*) int (*$\times$*) Bloc (*$\rightarrow$*) [Terrain]
		pre bloc( T, i, j, k, b) require 0 (*$\leq$*) i (*$\leq$*) largeur (*$\land$*) 0 (*$\leq$*) j (*$\leq$*) hauteur (*$\land$*) 0 (*$\leq$*) k (*$\leq$*) profondeur (*$\land$*) b (*$\neq$*) null
             
Observations :

      [(*$\specB{Invariants}$*)]
      
      [(*$\specB{init}$*)]
            largeur(init(l, h, p)) = l
            hauteur(init(l, h, p)) = h
            profondeur(init(l, h, p)) = p
            bloc(init(l, h, p), x, y, z) (*$\neq$*) NULL
            
      [(*$\specB{modifier\_bloc}$*)]
            bloc(modifier_bloc(T, x, y, z, b), x, y, z) = b 
            
\end{Spe}


\section{Moteur de jeu}
\begin{Spe}
service : MoteurJeu
use : GestionCombat
types : boolean, int, enum RESULTAT{DEUXGAGNANTS, RYANGAGNANT, ALEXGAGNANT, SLICKGAGNANT, NULLE},
        enum COMMANDE{RIEN, GAUCHE, DROITE, BAS, HAUT, FRAPPE, SAUT, SAUTHAUT, SAUTDROIT, SAUTGAUCHE, SAUTBAS,  RAMASSER, JETER}
Observators :
      estFini : [MoteurJeu] (*$\rightarrow$*) boolean
      resultat: [MoteurJeu] (*$\rightarrow$*) RESULTAT
            pre resultat(M) require estFini(M)
      combat : [MoteurJeu] (*$\rightarrow$*) GestionCombat
Constructors :
      init : (*$\emptyset$*) (*$\rightarrow$*) [MoteurJeu]
Operators :
      pasJeu : [MoteurJeu] (*$\times$*) COMMANDE (*$\times$*) COMMANDE (*$\rightarrow$*) [MoteurJeu]
            pre pasJeu(M,comAlex,comRyan) require : (*$\lnot$*)estFini(M)
Observations :
	[(*$\specB{Invariants}$*)]
	
(*estFini(M) $\stackrel{min}{=} \left\{
\begin{array}{ll}
  & $(Personnage:: estVaincu(GestionCombat::alex(combat(M))) $ \\  
  & \land $ Personnage::estVaincu(GestionCombat::ryan(combat(M))))$\\ 
  & \lor $ Gangster::estVaincu(GestionCombat::slick(combat(M)) $ 
\end{array} \right.$ *)

(*resultat(M)$  \stackrel{min}{=} \left\{\begin{array}{ll}
$ALEXGAGNANT$ & $si Personnage::!estVaincu(GestionCombat::alex(combat(M)))$ \\
& \land $ Gangster::estVaincu(GestionCombat::slick(combat(M)))$\\
& \land $ Personnage::estVaincu(GestionCombat::ryan(combat(M)))$ \\
\\
$RYANGAGNANT$ & $si Personnage::!estVaincu(GestionCombat::ryan(combat(M)))$ \\
& \land $ Gangster::estVaincu(GestionCombat::slick(combat(M))) $\\
& \land $ Personnage::estVaincu(GestionCombat::alex(combat(M))) $\\
\\
$DEUXGAGNANTS$ & $si Personnage::!estVaincu(GestionCombat::ryan(combat(M)))$ \\
& \land $ Gangster::estVaincu(GestionCombat::slick(combat(M))) $\\
& \land $ Personnage::!estVaincu(GestionCombat::alex(combat(M)))$ \\
\\
$SLICKGAGNANT$ & $si Personnage: estVaincu(GestionCombat::ryan(combat(M)))$ \\
& \land $ Gangster::!estVaincu(GestionCombat::slick(combat(M)))$\\
& \land $ Personnage::estVaincu(GestionCombat::alex(combat(M)))$ \\
\\
$NULLE$ & $sinon$ \\
 \end{array} \right.$*)
 
      [(*$\specB{init}$*)]
          combat(init()) = GestionCombat::init()
      [(*$\specB{pasJeu}$*)]
          combat(pasJeu(M,cA,cR)) = GestionCombat::gerer(combat(M), cA, cR)
            
\end{Spe}

\section{GestionCombat}
\begin{Spe}
service : GestionCombat
use : Terrain, Personnage, Gangster  
types : string, boolean, enum COMMANDE{RIEN, GAUCHE, DROITE, BAS, HAUT, FRAPPER, SAUT, SAUTHAUT, SAUTDROIT, SAUTGAUCHE, SAUTBAS,  RAMASSER, JETER}

Observators :
      terrain : [GestionCombat] (*$\rightarrow$*) Terrain
      alex : [GestionCombat] (*$\rightarrow$*) Personnage
      ryan : [GestionCombat] (*$\rightarrow$*) Personnage
      slick : [GestionCombat} (*$\rightarrow$*) Gangster
      gangsters :  [GestionCombat] (*$\rightarrow$*) Set<Gangster>
      estGele : [GestionCombat] (*$\times$*) Personnage (*$\rightarrow$*) boolean 
            pre estGele(G, perso) require perso = alex(G) (*$\lor$*) perso = ryan(G) (*$\lor$*) perso = slick(G) (*$\lor$*) perso (*$\in$*) gangsters(G)
      estFrappe : [GestionCombat] (*$\times$*) Personnage (*$\rightarrow$*) boolean 
            pre estFrappe(G, perso) require perso = alex(G) (*$\lor$*) perso = ryan(G) (*$\lor$*) perso = slick(G)  (*$\lor$*) perso (*$\in$*) gangsters(G)
      posX : [GestionCombat] (*$\times$*) Personnage (*$\rightarrow$*) int
            pre posX(G, perso) require perso = alex(G) (*$\lor$*) perso = ryan(G) (*$\lor$*) perso = slick(G)  (*$\lor$*) perso (*$\in$*) gangsters(G)
      posY : [GestionCombat] (*$\times$*) Personnage (*$\rightarrow$*) int 
            pre posY(G, perso) require perso = alex(G) (*$\lor$*) perso = ryan(G) (*$\lor$*) perso = slick(G)  (*$\lor$*) perso (*$\in$*) gangsters(G)
      posZ : [GestionCombat] (*$\times$*) Personnage (*$\rightarrow$*) int
            pre posZ(G, perso) require perso = alex(G) (*$\lor$*) perso = ryan(G) (*$\lor$*) perso = slick(G)  (*$\lor$*) perso (*$\in$*) gangsters(G)
      collision : [GestionCombat] (*$\times$*) Personnage (*$\times$*) Personnage (*$\rightarrow$*) boolean
            pre collision(G, perso1, perso2) require 
            
            (*$\lor$*) (perso1 = alex(G) (*$\land$*) perso2 (*$\in$*) gangsters(G))
            (*$\lor$*) (perso1 = alex(G) (*$\land$*) perso2 = slick(G))
            (*$\lor$*) (perso1 = ryan(G) (*$\land$*) perso2 (*$\in$*) gangsters(G))
            (*$\lor$*) (perso1 = ryan(G) (*$\land$*) perso2 = slick(G))

Constructors:
      init : (*$\emptyset$*) (*$\rightarrow$*) [GestionCombat]
      
Operators :
      gerer : [GestionCombat] (*$\times$*) COMMANDE (*$\times$*) COMMANDE (*$\rightarrow$*) [GestionCombat]

Observations : 
      [(*$\specB{Invariants}$*)]
      	0 <= posX(G,s) <= Terrain::largeur(terrain)
      	0 <= posY(G,s) <= Terrain::profondeur(terrain)
      	0 <= posZ(G,s) <= Terrain::hauteur(terrain)
      	collision(G,perso1,perso2)  (*$\stackrel{min}{=}$*) collision(G,perso2,perso1)
      	collision(G,p1,p2) (*$\stackrel{min}{=}$*) A FAIRE
            
      [(*$\specB{init}$*)]
    
	terrain(init()) = Terrain::init(1000,1000,1000)
	alex(init()) = Personnage::init("Alex",10,10,10,100,100,0)
	ryan(init()) = Personnage::init("Ryan",10,10,10,100,100,0)
	slick(init()) = Gangster::init("Slick",10,10,10,100,100,0)
	gangsters(init()) = {g = Personnage::init("???",10,10,10,100,100,0)}, (*$\forall$*) g (*$\in$*) gangsters(G)
	estGele(init(), s) = false
	collision(p1,p2) = false
	estFrappe(init(), s) = false
	posX(init(),alex(G)) < 50
	posX(init(),slick(G)) > Terrain::largeur(terrain(G))-50
	posX(init(),ryan(G)) < 50
	posZ(init(),p) = 0
	
	Bloc::type(Terrain:bloc(terrain(G),posX(init(),g),posY(init(),g),posZ(init(),g))) = VIDE (*$\forall$*) g (*$\in$*) gangsters(G)
	Bloc::type(Terrain:bloc(terrain(G),posX(init(),slick(G)),posY(init(),slick(G)),posZ(init(),slick(G)))) = VIDE
	Bloc::type(Terrain:bloc(terrain(G),posX(init(),alex(G)),posY(init(),alex(G)),posZ(init(),alex(G))))(*$\ne$*)FOSSE
	Bloc::type(Terrain:bloc(terrain(G),posX(init(),ryan(G)),posY(init(),ryan(G)),posZ(init(),ryan(G))))(*$\ne$*)FOSSE


	 [(*$\specB{gerer}$*)]
	 posX(gerer(G,cA,cR),alex(G)) =
	 	(*$ \left\{
\begin{array}{ll}
 $posX(G,alex(G)) + 10 $&$si cA = DROIT $\lor$ cA = SAUTDROIT $ \\
 $posX(G,alex(G)) - 10 $&$si cA = GAUCHE $\lor$ cA = SAUTGAUCHE $ \\
 $posX(G,alex(G)) $&$sinon $ 
\end{array} 
\right.$ *)
		
	 posY(gerer(G,cA,cR),alex(G)) = 
	 	(*$ \left\{
\begin{array}{ll}
	 	$posY(G,alex(G)) + 10 $&$si cA = HAUT $\lor$ cA = SAUTHAUT $ \\
	 	$posY(G,alex(G)) - 10 $&$si cA = BAS $\lor$ cA = SAUTBAS$ \\
	 	$posY(G,alex(G)) $&$sinon $
	 	\end{array} 
\right.$ *)

 	posZ(gerer(G,cA,cR),alex(G)) = 
	 	(*$ \left\{
\begin{array}{ll}
	 
	 	$10$&$si cA = SAUT $\lor$ cA = SAUTBAS $\lor$ cA = SAUTHAUT $\lor$ cA = SAUTDROIT $\lor$ cA = SAUTGAUCHE $ \\
		$0 $&$Sinon $
	 	\end{array} 
\right.$ *)
	
	 posX(gerer(G,cA,cR),ryan(G)) =
	 	(*$ \left\{
\begin{array}{ll}
 $posX(G,ryan(G)) + 10 $&$si cR = DROIT $\lor$ cR = SAUTDROIT $ \\
 $posX(G,ryan(G)) - 10 $&$si cR = GAUCHE $\lor$ cR = SAUTGAUCHE $ \\
 $posX(G,ryan(G)) $&$sinon $ 
\end{array} 
\right.$ *)

	 	
	 posY(gerer(G,cA,cR),ryan(G)) = 
	 	(*$ \left\{
\begin{array}{ll}
	 	$posY(G,ryan(G)) + 10 $&$si cR = HAUT $\lor$ cR = SAUTHAUT $ \\
	 	$posY(G,ryan(G)) - 10 $&$si cR = BAS $\lor$ cR = SAUTBAS$ \\
	 	$posY(G,ryan(G)) $&$sinon $
	 	\end{array} 
\right.$ *)

 	posZ(gerer(G,cA,cR),ryan(G)) = 
	 	(*$ \left\{
\begin{array}{ll}
	 
	 	$10$&$si cR = SAUT $\lor$ cR = SAUTBAS $\lor$ cR = SAUTHAUT $\lor$ cR = SAUTDROIT $\lor$ cR = SAUTGAUCHE $ \\
		$0 $&$Sinon $
	 	\end{array} 
\right.$ *)

		
	alex(gerer(G,cA,cR)) = 
 (*$ \left\{
\begin{array}{ll}
		$- Personnage::jeter(alex(G)) si cA = JETER$ \\
		$- Personnage::ramasser\_objet(alex(G), Bloc::objet(Terrain::bloc(terrain(G), posX(alex(G)), $\\$posY(alex(G)),posZ(alex(G)))) si cA = RAMASSER$ \\
		$- Personnage::ramasser\_perso(alex(G), p) si collision(alex(G), p) $\land$ cA = RAMASSER $ \\
		$- Personnage::retrait\_vie(alex(G), Personnage::force(p)) si collision(alex(G),p) $\land$ Gangster::action(p) = FRAPPER $ \\
		$- alex(G) Sinon$
		\end{array} 
\right.$ *)

	posX(gerer(G,cA,cR),p) = 
		posX(G,alex(G))+10 si cA = JETER  (*$\land$*) Personnage::perso_equipe(alex()) = p 
		posX(G,p) sinon
	posY(gerer(G,cA,cR),p) = 
		posY(G,alex(G)) si cA = JETER (*$\land$*) Personnage::perso_equipe(alex()) = p 
		posY(G,p) sinon
	posZ(gerer(G,cA,cR),p) = 
		0 si cA = JETER (*$\land$*) Personnage::perso_equipe(alex()) = p
		posZ(G,p) sinon
		
	slick(gerer(G,cA,cR)) = 
	(*$ \left\{
\begin{array}{ll}
		$- Gangster::retrait\_vie(slick(G),Personnage::force(h)) si collison(alex(G),slick(G)) $\land$ cA = FRAPPER $ \\
		$- Gangster::retrait\_vie(slick(G),Personnage::force(h)) si collison(ryan(G),slick(G)) $\land$ cR = FRAPPER $ \\
		$ - slick(G) sinon$
		\end{array} 
\right.$ *)	
	
	ryan(gerer(G,cA,cR)) = 
	(*$ \left\{
\begin{array}{ll}
		$- Personnage::jeter(ryan(G)) si cR = JETER$ \\
		$- Personnage::ramasser\_objet(ryan(G), Bloc::objet(Terrain::bloc(terrain(G), posX(ryan(G)), $\\$posY(ryan(G)),posZ(ryan(G)))) si cR = RAMASSER$ \\
		$- Personnage::ramasser\_perso(ryan(G), p) si collision(ryan(G), p) $\land$ cR = RAMASSER$ \\
		$- Personnage::retrait\_vie(ryan(G), Personnage::force(p)) si collision(ryan(G),p) $\land$ Gangster::action(p) = FRAPPER $ \\
		$- ryan(G) Sinon$
		\end{array} 
\right.$ *)

	posX(gerer(G,cA,cR),p) = 
		posX(ryan(G))+10 si cR = JETER  (*$\land$*) Personnage::perso_equipe(ryan()) = p 
		posX(G,p) sinon
		
	posY(gerer(G,cA,cR),p) = 
		posY(ryan(G)) si cR = JETER (*$\land$*) Personnage::perso_equipe(ryan()) = p 
		posY(G,p) sinon
	
	posZ(gerer(G,cA,cR),p) = 
		0 si cR = JETER (*$\land$*) Personnage::perso_equipe(ryan()) = p
		posZ(G,p) sinon


	terrain(gerer(G,cA,cR)) = 
	- Bloc::retirerObjet(Terrain::bloc(terrain(G), posX(alex(G)), posY(alex(G)),posZ(alex(G))) si cA = RAMASSER
	- Bloc::poserObjet(Terrain::bloc(terrain(G), posX(alex(G)), posY(alex(G)),posZ(alex(G))), Personnage:objet_equipe(alex()) si cA = JETER (*$\land$*) Personnage::est_equipe_objet(alex()) = true 
	- Bloc::retirerObjet(Terrain::bloc(terrain(G), posX(ryan(G)), posY(ryan(G)),posZ(ryan(G))) si cR = RAMASSER
	- Bloc::poserObjet(Terrain::bloc(terrain(G), posX(ryan(G)), posY(ryan(G)),posZ(ryan(G))), Personnage:objet_equipe(ryan()) si cR = JETER (*$\land$*) Personnage::est_equipe_objet(ryan()) = true 
	- terrain(G) sinon // Faut il faire aussi les deux ?????
	
	



\end{Spe}

\end{document}
